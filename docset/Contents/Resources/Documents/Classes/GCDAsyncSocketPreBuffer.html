<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>GCDAsyncSocketPreBuffer Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">GIGATMSSDK </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">GIGATMS.INC</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	

	
	
	

	
	

	

	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">GCDAsyncSocketPreBuffer Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>GCDAsyncSocket.m</td>
</tr>
						</tbody></table></div>
					

                    
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>A PreBuffer is used when there is more data available on the socket
than is being requested by current read request.
In this case we slurp up all data from the socket (to minimize sys calls),
and store additional yet unread data in a &ldquo;prebuffer&rdquo;.</p>

<p>The prebuffer is entirely drained before we read from the socket again.
In other words, a large chunk of data is written is written to the prebuffer.
The prebuffer is then drained via a series of one or more reads (for subsequent read request(s)).</p>

<p>A ring buffer was once used for this purpose.
But a ring buffer takes up twice as much memory as needed (double the size for mirroring).
In fact, it generally takes up more than twice the needed size as everything has to be rounded up to vm_page_size.
And since the prebuffer is always completely drained after being written to, a full ring buffer isn&rsquo;t needed.</p>

<p>The current design is very simple and straight-forward, while also keeping memory requirements lower.</p>
					</div>
					
					

					
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2021 GIGATMS.INC. All rights reserved. Updated: 2021-03-26</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>