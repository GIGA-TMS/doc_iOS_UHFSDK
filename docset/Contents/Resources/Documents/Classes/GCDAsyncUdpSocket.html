<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>GCDAsyncUdpSocket Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">GIGATMSSDK_UHF </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">GIGATMS.INC</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	
	<optgroup label="Class Methods">
		
		<option value="//api/name/hostFromAddress:">+ hostFromAddress:</option>
		
	</optgroup>
	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/asyncResolveHost:port:withCompletionBlock:">- asyncResolveHost:port:withCompletionBlock:</option>
		
		<option value="//api/name/beginReceiving:">- beginReceiving:</option>
		
		<option value="//api/name/bindToAddress:error:">- bindToAddress:error:</option>
		
		<option value="//api/name/bindToPort:error:">- bindToPort:error:</option>
		
		<option value="//api/name/bindToPort:interface:error:">- bindToPort:interface:error:</option>
		
		<option value="//api/name/close">- close</option>
		
		<option value="//api/name/closeAfterSending">- closeAfterSending</option>
		
		<option value="//api/name/connectToAddress:error:">- connectToAddress:error:</option>
		
		<option value="//api/name/connectToHost:onPort:error:">- connectToHost:onPort:error:</option>
		
		<option value="//api/name/connectedAddress">- connectedAddress</option>
		
		<option value="//api/name/convertIntefaceDescription:port:intoAddress4:address6:">- convertIntefaceDescription:port:intoAddress4:address6:</option>
		
		<option value="//api/name/convertNumericHost:port:intoAddress4:address6:">- convertNumericHost:port:intoAddress4:address6:</option>
		
		<option value="//api/name/createSockets:">- createSockets:</option>
		
		<option value="//api/name/doPreSend">- doPreSend</option>
		
		<option value="//api/name/doSend">- doSend</option>
		
		<option value="//api/name/doSendTimeout">- doSendTimeout</option>
		
		<option value="//api/name/endCurrentSend">- endCurrentSend</option>
		
		<option value="//api/name/getAddress:error:fromAddresses:">- getAddress:error:fromAddresses:</option>
		
		<option value="//api/name/init">- init</option>
		
		<option value="//api/name/isClosed">- isClosed</option>
		
		<option value="//api/name/isConnected">- isConnected</option>
		
		<option value="//api/name/isIPv4">- isIPv4</option>
		
		<option value="//api/name/isIPv4Enabled">- isIPv4Enabled</option>
		
		<option value="//api/name/isIPv6">- isIPv6</option>
		
		<option value="//api/name/joinMulticastGroup:error:">- joinMulticastGroup:error:</option>
		
		<option value="//api/name/joinMulticastGroup:onInterface:error:">- joinMulticastGroup:onInterface:error:</option>
		
		<option value="//api/name/localAddress">- localAddress</option>
		
		<option value="//api/name/markSocketQueueTargetQueue:">- markSocketQueueTargetQueue:</option>
		
		<option value="//api/name/maxReceiveIPv4BufferSize">- maxReceiveIPv4BufferSize</option>
		
		<option value="//api/name/maxSendBufferSize">- maxSendBufferSize</option>
		
		<option value="//api/name/pauseReceiving">- pauseReceiving</option>
		
		<option value="//api/name/performBlock:">- performBlock:</option>
		
		<option value="//api/name/preBind:">- preBind:</option>
		
		<option value="//api/name/preConnect:">- preConnect:</option>
		
		<option value="//api/name/readStream">- readStream</option>
		
		<option value="//api/name/sendData:toAddress:withTimeout:tag:">- sendData:toAddress:withTimeout:tag:</option>
		
		<option value="//api/name/sendData:toHost:port:withTimeout:tag:">- sendData:toHost:port:withTimeout:tag:</option>
		
		<option value="//api/name/sendData:withTimeout:tag:">- sendData:withTimeout:tag:</option>
		
		<option value="//api/name/sendTimeoutError">- sendTimeoutError</option>
		
		<option value="//api/name/setReceiveFilter:withQueue:">- setReceiveFilter:withQueue:</option>
		
		<option value="//api/name/setReceiveFilter:withQueue:isAsynchronous:">- setReceiveFilter:withQueue:isAsynchronous:</option>
		
		<option value="//api/name/setSendFilter:withQueue:">- setSendFilter:withQueue:</option>
		
		<option value="//api/name/setSendFilter:withQueue:isAsynchronous:">- setSendFilter:withQueue:isAsynchronous:</option>
		
		<option value="//api/name/setupSendTimerWithTimeout:">- setupSendTimerWithTimeout:</option>
		
		<option value="//api/name/socketFD">- socketFD</option>
		
		<option value="//api/name/unmarkSocketQueueTargetQueue:">- unmarkSocketQueueTargetQueue:</option>
		
		<option value="//api/name/userData">- userData</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">GCDAsyncUdpSocket Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>GCDAsyncUdpSocket.h<br />GCDAsyncUdpSocket.m</td>
</tr>
						</tbody></table></div>
					

                    

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="method-title"><code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>GCDAsyncUdpSocket uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (instancetype)init</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>GCDAsyncUdpSocket uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>

<p>You MUST set a <a href="#//api/name/delegate">delegate</a> AND <a href="#//api/name/delegate">delegate</a> dispatch queue before attempting to
use the socket, or you will get an error.</p>

<p>The socket queue is optional.
If you pass NULL, <a href="../Classes/GCDAsyncSocket.html">GCDAsyncSocket</a> will automatically create its own socket queue.
If you choose to provide a socket queue, the socket queue must not be a concurrent queue,
then please see the discussion for the method markSocketQueueTargetQueue.</p>

<p>The <a href="#//api/name/delegate">delegate</a> queue and socket queue can optionally be the same.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv4Enabled" title="isIPv4Enabled"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv4Enabled">&ndash;&nbsp;isIPv4Enabled</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>By default, both IPv4 and IPv6 are enabled.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Enabled</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>By default, both IPv4 and IPv6 are enabled.</p>

<p>This means GCDAsyncUdpSocket automatically supports both protocols,
and can send to IPv4 or IPv6 addresses,
as well as receive over IPv4 and IPv6.</p>

<p>For operations that require DNS resolution, GCDAsyncUdpSocket supports both IPv4 and IPv6.
If a DNS lookup returns only IPv4 results, GCDAsyncUdpSocket will automatically use IPv4.
If a DNS lookup returns only IPv6 results, GCDAsyncUdpSocket will automatically use IPv6.
If a DNS lookup returns both IPv4 and IPv6 results, then the protocol used depends on the configured preference.
If IPv4 is preferred, then IPv4 is used.
If IPv6 is preferred, then IPv6 is used.
If neutral, then the first IP version in the resolved array will be used.</p>

<p>Starting with Mac OS X 10.7 Lion and iOS 5, the default IP preference is neutral.
On prior systems the default IP preference is IPv4.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maxReceiveIPv4BufferSize" title="maxReceiveIPv4BufferSize"></a>
	<h3 class="method-title"><code><a href="#//api/name/maxReceiveIPv4BufferSize">&ndash;&nbsp;maxReceiveIPv4BufferSize</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 65535 bytes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (uint16_t)maxReceiveIPv4BufferSize</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 65535 bytes.</p>

<p>The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.
The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295.</p>

<p>Since the OS/GCD notifies us of the size of each received UDP packet,
the actual allocated buffer size for each packet is exact.
And in practice the size of UDP packets is generally much smaller than the max.
Indeed most protocols will send and receive packets of only a few bytes,
or will set a limit on the size of packets to prevent fragmentation in the IP layer.</p>

<p>If you set the buffer size too small, the sockets API in the OS will silently discard
any extra data, and you will not be notified of the error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maxSendBufferSize" title="maxSendBufferSize"></a>
	<h3 class="method-title"><code><a href="#//api/name/maxSendBufferSize">&ndash;&nbsp;maxSendBufferSize</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Gets/Sets the maximum size of the buffer that will be allocated for send operations.
The default maximum size is 65535 bytes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (uint16_t)maxSendBufferSize</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Gets/Sets the maximum size of the buffer that will be allocated for send operations.
The default maximum size is 65535 bytes.</p>

<p>Given that a typical link MTU is 1500 bytes, a large UDP datagram will have to be
fragmented, and that’s both expensive and risky (if one fragment goes missing, the
entire datagram is lost).  You are much better off sending a large number of smaller
UDP datagrams, preferably using a path MTU algorithm to avoid fragmentation.</p>

<p>You must set it before the sockt is created otherwise it won&rsquo;t work.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/userData" title="userData"></a>
	<h3 class="method-title"><code><a href="#//api/name/userData">&ndash;&nbsp;userData</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (id)userData</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendTimeoutError" title="sendTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendTimeoutError">&ndash;&nbsp;sendTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard send timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)sendTimeoutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard send timeout error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/asyncResolveHost:port:withCompletionBlock:" title="asyncResolveHost:port:withCompletionBlock:"></a>
	<h3 class="method-title"><code><a href="#//api/name/asyncResolveHost:port:withCompletionBlock:">&ndash;&nbsp;asyncResolveHost:port:withCompletionBlock:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method executes on a global concurrent queue.
When complete, it executes the given completion block on the socketQueue.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)asyncResolveHost:(NSString *)<em>aHost</em> port:(uint16_t)<em>port</em> withCompletionBlock:(void ( ^ ) ( NSArray *addresses , NSError *error ))<em>completionBlock</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method executes on a global concurrent queue.
When complete, it executes the given completion block on the socketQueue.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getAddress:error:fromAddresses:" title="getAddress:error:fromAddresses:"></a>
	<h3 class="method-title"><code><a href="#//api/name/getAddress:error:fromAddresses:">&ndash;&nbsp;getAddress:error:fromAddresses:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method picks an address from the given list of addresses.
The address picked depends upon which protocols are disabled, deactived, &amp; preferred.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (int)getAddress:(NSData **)<em>addressPtr</em> error:(NSError **)<em>errorPtr</em> fromAddresses:(NSArray *)<em>addresses</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method picks an address from the given list of addresses.
The address picked depends upon which protocols are disabled, deactived, &amp; preferred.</p>

<p>Returns the address family (AF_INET or AF_INET6) of the picked address,
or AF_UNSPEC and the corresponding error is there&rsquo;s a problem.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/convertIntefaceDescription:port:intoAddress4:address6:" title="convertIntefaceDescription:port:intoAddress4:address6:"></a>
	<h3 class="method-title"><code><a href="#//api/name/convertIntefaceDescription:port:intoAddress4:address6:">&ndash;&nbsp;convertIntefaceDescription:port:intoAddress4:address6:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Finds the address(es) of an interface description.
An inteface description may be an interface name (en0, en1, lo0) or corresponding IP (192.168.4.34).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)convertIntefaceDescription:(NSString *)<em>interfaceDescription</em> port:(uint16_t)<em>port</em> intoAddress4:(NSData **)<em>interfaceAddr4Ptr</em> address6:(NSData **)<em>interfaceAddr6Ptr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Finds the address(es) of an interface description.
An inteface description may be an interface name (en0, en1, lo0) or corresponding IP (192.168.4.34).</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/convertNumericHost:port:intoAddress4:address6:" title="convertNumericHost:port:intoAddress4:address6:"></a>
	<h3 class="method-title"><code><a href="#//api/name/convertNumericHost:port:intoAddress4:address6:">&ndash;&nbsp;convertNumericHost:port:intoAddress4:address6:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Converts a numeric hostname into its corresponding address.
The hostname is expected to be an IPv4 or IPv6 address represented as a human-readable string. (e.g. 192.168.4.34)</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)convertNumericHost:(NSString *)<em>numericHost</em> port:(uint16_t)<em>port</em> intoAddress4:(NSData **)<em>addr4Ptr</em> address6:(NSData **)<em>addr6Ptr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Converts a numeric hostname into its corresponding address.
The hostname is expected to be an IPv4 or IPv6 address represented as a human-readable string. (e.g. 192.168.4.34)</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/createSockets:" title="createSockets:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createSockets:">&ndash;&nbsp;createSockets:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.
The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)createSockets:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.
The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295.</p>

<p>The default maximum size of the UDP buffer in iOS is 9216 bytes.</p>

<p>This is the reason of #222(GCD does not necessarily return the size of an entire UDP packet) and</p>

<h1>535(GCDAsyncUDPSocket can not send data when data is greater than 9K)</h1>

<p>Enlarge the maximum size of UDP packet.
I can not ensure the protocol type now so that the max size is set to 65535 :)</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/localAddress" title="localAddress"></a>
	<h3 class="method-title"><code><a href="#//api/name/localAddress">&ndash;&nbsp;localAddress</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the local address info for the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)localAddress</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns the local address info for the socket.</p>

<p>The localAddress method returns a sockaddr structure wrapped in a NSData object.
The <a href="#//api/name/localHost">localHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Address info may not be available until after the socket has been binded, connected
or until after data has been sent.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the remote address info for the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns the remote address info for the socket.</p>

<p>The connectedAddress method returns a sockaddr structure wrapped in a NSData object.
The <a href="#//api/name/connectedHost">connectedHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Since UDP is connectionless by design, connected address info
will not be available unless the socket is explicitly connected to a remote host/port.
If the socket is not connected, these methods will return nil / 0.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="method-title"><code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isClosed" title="isClosed"></a>
	<h3 class="method-title"><code><a href="#//api/name/isClosed">&ndash;&nbsp;isClosed</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isClosed</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket is IPv4.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns whether or not this socket is IPv4.</p>

<p>By default this will be true, unless:
- IPv4 is disabled (via setIPv4Enabled:)
- The socket is explicitly bound to an IPv6 address
- The socket is connected to an IPv6 address</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether or not this socket is IPv6.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns whether or not this socket is IPv6.</p>

<p>By default this will be true, unless:
- IPv6 is disabled (via setIPv6Enabled:)
- The socket is explicitly bound to an IPv4 address
_ The socket is connected to an IPv4 address</p>

<p>This method will also return false on platforms that do not support IPv6.
Note: The iPhone does not currently support IPv6.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/preBind:" title="preBind:"></a>
	<h3 class="method-title"><code><a href="#//api/name/preBind:">&ndash;&nbsp;preBind:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method runs through the various checks required prior to a bind attempt.
It is shared between the various bind methods.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)preBind:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method runs through the various checks required prior to a bind attempt.
It is shared between the various bind methods.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToPort:error:" title="bindToPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToPort:error:">&ndash;&nbsp;bindToPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You may optionally pass a port number of zero to immediately bind the socket,
yet still allow the OS to automatically assign an available port.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToPort:interface:error:" title="bindToPort:interface:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToPort:interface:error:">&ndash;&nbsp;bindToPort:interface:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> interface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You may optionally pass a port number of zero to immediately bind the socket,
yet still allow the OS to automatically assign an available port.</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept packets from the local machine.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bindToAddress:error:" title="bindToAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/bindToAddress:error:">&ndash;&nbsp;bindToAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)bindToAddress:(NSData *)<em>localAddr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/preConnect:" title="preConnect:"></a>
	<h3 class="method-title"><code><a href="#//api/name/preConnect:">&ndash;&nbsp;preConnect:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method runs through the various checks required prior to a connect attempt.
It is shared between the various connect methods.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)preConnect:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method runs through the various checks required prior to a connect attempt.
It is shared between the various connect methods.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</p>

<p>Choosing to connect to a specific host/port has the following effect:
- You will only be able to send data to the connected host/port.
- You will only be able to receive data from the connected host/port.
- You will receive ICMP messages that come from the connected host/port, such as &ldquo;connection refused&rdquo;.</p>

<p>The actual process of connecting a UDP socket does not result in any communication on the socket.
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after it has been connected.
You can only connect a socket once.</p>

<p>The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).</p>

<p>This method is asynchronous as it requires a DNS lookup to resolve the given host name.
If an obvious error is detected, this method immediately returns NO and sets errPtr.
If you don&rsquo;t care about the error, you can pass nil for errPtr.
Otherwise, this method returns YES and begins the asynchronous connection process.
The result of the asynchronous connection process will be reported via the delegate methods.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>By design, UDP is a connectionless protocol, and connecting is not needed.</p>

<p>Choosing to connect to a specific address has the following effect:
- You will only be able to send data to the connected address.
- You will only be able to receive data from the connected address.
- You will receive ICMP messages that come from the connected address, such as &ldquo;connection refused&rdquo;.</p>

<p>Connecting a UDP socket does not result in any communication on the socket.
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after its been connected.
You can only connect a socket once.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>

<p>Note: Unlike the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method, this method does not require a DNS lookup.
Thus when this method returns, the connection has either failed or fully completed.
In other words, this method is synchronous, unlike the asynchronous connectToHost::: method.
However, for compatibility and simplification of delegate code, if this method returns YES
then the corresponding delegate method (udpSocket:didConnectToHost:port:) is still invoked.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/joinMulticastGroup:error:" title="joinMulticastGroup:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/joinMulticastGroup:error:">&ndash;&nbsp;joinMulticastGroup:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/joinMulticastGroup:onInterface:error:" title="joinMulticastGroup:onInterface:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/joinMulticastGroup:onInterface:error:">&ndash;&nbsp;joinMulticastGroup:onInterface:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> onInterface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:withTimeout:tag:" title="sendData:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:withTimeout:tag:">&ndash;&nbsp;sendData:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Asynchronously sends the given data, with the given timeout and tag.</p>

<p>This method may only be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the delegate method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCDAsyncUdpSocket does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:toHost:port:withTimeout:tag:" title="sendData:toHost:port:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:toHost:port:withTimeout:tag:">&ndash;&nbsp;sendData:toHost:port:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toHost:(NSString *)<em>host</em> port:(uint16_t)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>

<p>This method cannot be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param host
The destination to send the udp packet to.
May be specified as a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).
You may also use the convenience strings of &ldquo;loopback&rdquo; or &ldquo;localhost&rdquo;.</p>

<p>@param port
The port of the host to send to.</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the delegate method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCDAsyncUdpSocket does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/sendData:toAddress:withTimeout:tag:" title="sendData:toAddress:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/sendData:toAddress:withTimeout:tag:">&ndash;&nbsp;sendData:toAddress:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>

<p>This method cannot be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param remoteAddr
The address to send the data to (specified as a sockaddr structure wrapped in a NSData object).</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the delegate method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCDAsyncUdpSocket does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:" title="setSendFilter:withQueue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setSendFilter:withQueue:">&ndash;&nbsp;setSendFilter:withQueue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</p>

<ol>
<li><p>Optional caching of resolved addresses for domain names.
The cache could later be consulted, resulting in fewer system calls to getaddrinfo.</p></li>
<li><p>Reusable modules of code for bandwidth monitoring.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.
A filter allows you to write custom code to simulate such environments.
The ability to code this yourself is especially helpful when your simulated environment
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>


<p>For more information about <a href="../Blocks/GCDAsyncUdpSocketSendFilterBlock.html">GCDAsyncUdpSocketSendFilterBlock</a>, see the documentation for its typedef.
To remove a previously set filter, invoke this method and pass a nil filterBlock and NULL filterQueue.</p>

<p>Note: This method invokes <a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">setSendFilter:withQueue:isAsynchronous:</a> (documented below),
passing YES for the isAsynchronous parameter.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:isAsynchronous:" title="setSendFilter:withQueue:isAsynchronous:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">&ndash;&nbsp;setSendFilter:withQueue:isAsynchronous:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em> isAsynchronous:(BOOL)<em>isAsynchronous</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>

<p>However, there are a few situations in which synchronous operation is preferred.
Such is the case when the filter is extremely minimal and fast.
This is because dispatch_sync is faster than dispatch_async.</p>

<p>If you choose synchronous operation, be aware of possible deadlock conditions.
Since the socket queue is executing your block via dispatch_sync,
then you cannot perform any tasks which may invoke dispatch_sync on the socket queue.
For example, you can&rsquo;t query properties on the socket.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doPreSend" title="doPreSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/doPreSend">&ndash;&nbsp;doPreSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is called after a sendPacket has been dequeued.
It performs various preprocessing checks on the packet,
and queries the send<a href="../Constants/Filter.html">Filter</a> (if set) to determine if the packet can be sent.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doPreSend</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is called after a sendPacket has been dequeued.
It performs various preprocessing checks on the packet,
and queries the send<a href="../Constants/Filter.html">Filter</a> (if set) to determine if the packet can be sent.</p>

<p>If the packet passes all checks, it will be passed on to the <a href="#//api/name/doSend">doSend</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSend" title="doSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSend">&ndash;&nbsp;doSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method performs the actual sending of data in the currentSend packet.
It should only be called if the</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSend</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method performs the actual sending of data in the currentSend packet.
It should only be called if the</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/endCurrentSend" title="endCurrentSend"></a>
	<h3 class="method-title"><code><a href="#//api/name/endCurrentSend">&ndash;&nbsp;endCurrentSend</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Releases all resources associated with the currentSend.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)endCurrentSend</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Releases all resources associated with the currentSend.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSendTimeout" title="doSendTimeout"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSendTimeout">&ndash;&nbsp;doSendTimeout</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Performs the operations to timeout the current send operation, and move on.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSendTimeout</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Performs the operations to timeout the current send operation, and move on.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setupSendTimerWithTimeout:" title="setupSendTimerWithTimeout:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setupSendTimerWithTimeout:">&ndash;&nbsp;setupSendTimerWithTimeout:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Sets up a timer that fires to timeout the current send operation.
This method should only be called once per send packet.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setupSendTimerWithTimeout:(NSTimeInterval)<em>timeout</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Sets up a timer that fires to timeout the current send operation.
This method should only be called once per send packet.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/beginReceiving:" title="beginReceiving:"></a>
	<h3 class="method-title"><code><a href="#//api/name/beginReceiving:">&ndash;&nbsp;beginReceiving:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)beginReceiving:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>

<p>In one-at-a-time mode, you call receiveOnce everytime your delegate is ready to process an incoming udp packet.
Receiving packets one-at-a-time may be better suited for implementing certain state machine code,
where your state machine may not always be ready to process incoming packets.</p>

<p>In continuous mode, the delegate is invoked immediately everytime incoming udp packets are received.
Receiving packets continuously is better suited to real-time streaming applications.</p>

<p>You may switch back and forth between one-at-a-time mode and continuous mode.
If the socket is currently in one-at-a-time mode, calling this method will switch it to continuous mode.</p>

<p>For every received packet (not filtered by the optional receive filter),
the delegate method (udpSocket:didReceiveData:fromAddress:withFilterContext:) is invoked.</p>

<p>If the socket is able to begin receiving packets, this method returns YES.
Otherwise it returns NO, and sets the errPtr with appropriate error information.</p>

<p>An example error:
You created a udp socket to act as a server, and immediately called receive.
You forgot to first bind the socket to a port number, and received a error with a message like:
&ldquo;Must bind socket before you can receive data.&rdquo;</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/pauseReceiving" title="pauseReceiving"></a>
	<h3 class="method-title"><code><a href="#//api/name/pauseReceiving">&ndash;&nbsp;pauseReceiving</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)pauseReceiving</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p>

<p>Important Note:
GCDAsyncUdpSocket may be running in parallel with your code.
That is, your delegate is likely running on a separate thread/dispatch_queue.
When you invoke this method, GCDAsyncUdpSocket may have already dispatched delegate methods to be invoked.
Thus, if those delegate methods have already been dispatch_async&rsquo;d,
your didReceive delegate method may still be invoked after this method has been called.
You should be aware of this, and program defensively.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setReceiveFilter:withQueue:" title="setReceiveFilter:withQueue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setReceiveFilter:withQueue:">&ndash;&nbsp;setReceiveFilter:withQueue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>You may optionally set a receive filter for the socket.
This receive filter may be set to run in its own queue (independent of delegate queue).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>You may optionally set a receive filter for the socket.
This receive filter may be set to run in its own queue (independent of delegate queue).</p>

<p>A filter can provide several useful features.</p>

<ol>
<li><p>Many times udp packets need to be parsed.
Since the filter can run in its own independent queue, you can parallelize this parsing quite easily.
The end result is a parallel socket io, datagram parsing, and packet processing.</p></li>
<li><p>Many times udp packets are discarded because they are duplicate/unneeded/unsolicited.
The filter can prevent such packets from arriving at the delegate.
And because the filter can run in its own independent queue, this doesn&rsquo;t slow down the delegate.</p></li>
<li><p>Since the udp protocol does not guarantee delivery, udp packets may be lost.
Many protocols built atop udp thus provide various resend/re-request algorithms.
This sometimes results in duplicate packets arriving.
A filter may allow you to architect the duplicate detection code to run in parallel to normal processing.</p></li>
<li><p>Since the udp socket may be connectionless, its possible for unsolicited packets to arrive.
Such packets need to be ignored.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.
A filter allows you to write custom code to simulate such environments.
The ability to code this yourself is especially helpful when your simulated environment
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>


<p>Example:</p>

<p><a href="../Blocks/GCDAsyncUdpSocketReceiveFilterBlock.html">GCDAsyncUdpSocketReceiveFilterBlock</a> filter = ^BOOL (NSData <em>data, NSData </em>address, id *context) {</p>

<p>MyProtocolMessage *msg = [MyProtocol parseMessage:data];</p>

<p>*context = response;
return (response != nil);
};
[udpSocket setReceive<a href="../Constants/Filter.html">Filter</a>:filter withQueue:myParsingQueue];</p>

<p>For more information about <a href="../Blocks/GCDAsyncUdpSocketReceiveFilterBlock.html">GCDAsyncUdpSocketReceiveFilterBlock</a>, see the documentation for its typedef.
To remove a previously set filter, invoke this method and pass a nil filterBlock and NULL filterQueue.</p>

<p>Note: This method invokes <a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">setReceiveFilter:withQueue:isAsynchronous:</a> (documented below),
passing YES for the isAsynchronous parameter.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setReceiveFilter:withQueue:isAsynchronous:" title="setReceiveFilter:withQueue:isAsynchronous:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">&ndash;&nbsp;setReceiveFilter:withQueue:isAsynchronous:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em> isAsynchronous:(BOOL)<em>isAsynchronous</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>

<p>However, there are a few situations in which synchronous operation is preferred.
Such is the case when the filter is extremely minimal and fast.
This is because dispatch_sync is faster than dispatch_async.</p>

<p>If you choose synchronous operation, be aware of possible deadlock conditions.
Since the socket queue is executing your block via dispatch_sync,
then you cannot perform any tasks which may invoke dispatch_sync on the socket queue.
For example, you can&rsquo;t query properties on the socket.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/close" title="close"></a>
	<h3 class="method-title"><code><a href="#//api/name/close">&ndash;&nbsp;close</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Immediately closes the underlying socket.
Any pending send operations are discarded.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)close</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Immediately closes the underlying socket.
Any pending send operations are discarded.</p>

<p>The GCDAsyncUdpSocket instance may optionally be used again.
(it will setup/configure/use another unnderlying BSD socket).</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/closeAfterSending" title="closeAfterSending"></a>
	<h3 class="method-title"><code><a href="#//api/name/closeAfterSending">&ndash;&nbsp;closeAfterSending</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Closes the underlying socket after all pending send operations have been sent.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)closeAfterSending</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Closes the underlying socket after all pending send operations have been sent.</p>

<p>The GCDAsyncUdpSocket instance may optionally be used again.
(it will setup/configure/use another unnderlying BSD socket).</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/markSocketQueueTargetQueue:" title="markSocketQueueTargetQueue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/markSocketQueueTargetQueue:">&ndash;&nbsp;markSocketQueueTargetQueue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>See header file for big discussion of this method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)markSocketQueueTargetQueue:(dispatch_queue_t)<em>socketNewTargetQueue</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>See header file for big discussion of this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/unmarkSocketQueueTargetQueue:" title="unmarkSocketQueueTargetQueue:"></a>
	<h3 class="method-title"><code><a href="#//api/name/unmarkSocketQueueTargetQueue:">&ndash;&nbsp;unmarkSocketQueueTargetQueue:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>See header file for big discussion of this method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)unmarkSocketQueueTargetQueue:(dispatch_queue_t)<em>socketOldTargetQueue</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>See header file for big discussion of this method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/performBlock:" title="performBlock:"></a>
	<h3 class="method-title"><code><a href="#//api/name/performBlock:">&ndash;&nbsp;performBlock:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)performBlock:(dispatch_block_t)<em>block</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>

<p>For example, the socket file descriptor.
File descriptors are simply integers which reference an index in the per-process file table.
However, when one requests a new file descriptor (by opening a file or socket),
the file descriptor returned is guaranteed to be the lowest numbered unused descriptor.
So if we&rsquo;re not careful, the following could be possible:</p>

<ul>
<li>Thread A invokes a method which returns the socket&rsquo;s file descriptor.</li>
<li>The socket is closed via the socket&rsquo;s internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket&rsquo;s FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>


<p>In addition to this, other variables are not actually objects,
and thus cannot be retained/released or even autoreleased.
An example is the sslContext, of type SSLContextRef, which is actually a malloc&rsquo;d struct.</p>

<p>Although there are internal variables that make it difficult to maintain thread-safety,
it is important to provide access to these variables
to ensure this class can be used in a wide array of environments.
This method helps to accomplish this by invoking the current block on the socket&rsquo;s internal queue.
The methods below can be invoked from within the block to access
those generally thread-unsafe internal variables in a thread-safe manner.
The given block will be invoked synchronously on the socket&rsquo;s internal queue.</p>

<p>If you save references to any protected variables and use them outside the block, you do so at your own peril.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/socketFD" title="socketFD"></a>
	<h3 class="method-title"><code><a href="#//api/name/socketFD">&ndash;&nbsp;socketFD</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (int)socketFD</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s file descriptor(s).
If the socket isn&rsquo;t connected, or explicity bound to a particular interface,
it might actually have multiple internal socket file descriptors - one for IPv4 and one for IPv6.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readStream" title="readStream"></a>
	<h3 class="method-title"><code><a href="#//api/name/readStream">&ndash;&nbsp;readStream</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (CFReadStreamRef)readStream</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Returns (creating if necessary) a CFReadStream/CFWriteStream for the internal socket.</p>

<p>Generally GCDAsyncUdpSocket doesn&rsquo;t use CFStream. (It uses the faster GCD API&rsquo;s.)
However, if you need one for any reason,
these methods are a convenient way to get access to a safe instance of one.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/hostFromAddress:" title="hostFromAddress:"></a>
	<h3 class="method-title"><code><a href="#//api/name/hostFromAddress:">+&nbsp;hostFromAddress:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Extracting host/port/family information from raw address data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (NSString *)hostFromAddress:(NSData *)<em>address</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Extracting host/port/family information from raw address data.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">GCDAsyncUdpSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2021 GIGATMS.INC. All rights reserved. Updated: 2021-03-26</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>